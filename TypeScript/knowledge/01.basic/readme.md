# 小写类型
- boolean
- string
- number
- bigint，与number不兼容
- symbol
- undefined、null
  - null和undefined既可以作为值也可以作为类型
  - 作为值时，其类型在没有开启noImpliciAny和strictNullChecks时会被推断为any
  - 任何类型都可以被赋值为undefined或null，并非因为其他类型包含这两个类型，只是为了与js保持一致，可以开启strictNullChecks禁止其他类型赋值为null或undefined，且null和undefined也不能相互赋值
- object
  - 狭义对象，只包含用字面量表示的对象，不包含原始值

# 特殊类型
- any，没有类型限定可以赋值任意类型
  - 开启noImpliciAny，只要推导出any就报错
  - 特殊情况是使用let和var声明的变量不赋值也不初始化是不会报错的
  - 存在污染问题，即它可以赋值给任意类型变量（因为没有类型检查）
- unknow，表示类型不确定
  - 与any相似之处在于所有类型的值都可以分配给unknow，不同之处在于其不能直接赋值给其他类型变量，且不能直接调用unknow变量的属性和方法或作为函数调用
  - 其类型变量能使用的运算符也有限制，只能进行比较、取反、typeof和instanceof
  - 要使用只能“类型缩小”
- never，即不存在这样的值，不能赋给它任何类型
  - 不可能返回值的函数

# 大写类型
- Boolean、String、Number
  - 可以使用其构造函数（非普通函数）进行转换
- BigInt、Symbol
  - 只能使用Object()包裹其原始值生成
- Object
  - 广义对象，包含所有可以转换为对象的值（除了null和undefined）
- 小写类型不兼容大写类型，但是大写类型兼容小写类型

# 值类型
- 遇到const命令声明的变量，如果没有注明类型，则ts推断为值类型，对于对象则不会推导为值类型
  - 这样是合理的，因为基本类型的const值不能改变，而对象的属性是可以改变的

# 联合类型
- A|B表示一个类型可以属于A或者B，但是使用的时候需要“类型缩小”
  - 因为编译器不确定使用的是那个值类型，不进行“类型缩小”只能使用类型公共方法
  - 使用的时候明确赋值则不需要“类型缩小”，编译器已经知道该值是什么类型了

# 交叉类型
- A&B，表示多个类型组成一个新类型，即这个类型必须同时属于A和B，不满足要求则推导为never
  - 主要是表示对象的合成
  - 也可以用来给对象类型添加属性

# typeof
- 返回一个操作数的类型，其参数只能是标志符而不是需要运算的表达式或类型

# 数组
- 如果变量的初始值是空数组，则推断为any[]，如果开启了不允许推导any，则推导为never
- 在数组类型前添加readonly，不允许新增、删除、修改成员
  - 不能与泛型一块使用，readonly Array<type>报错

# 元组
- 元组必须明确指定每个成员的类型，使用元组必须明确给出一个类型，否则推断为数组
- 成员可以使用? 
- 使用扩展运算符表示不限定成员数量的元组，写在任意位置都可
- 扩充成员则类型必须是元组定义类型的联合类型