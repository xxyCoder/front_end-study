# 模块
- 现代JS开发会遇到代码量大以及第三方库引用问题，解决需要将代码拆分成很多块，然后通过某种方式将其连接起来，这就是模块
- 把逻辑分块，各自封装，相互独立，每个块自行决定对外暴露什么，同时自行决定将哪些块引入

## 模块依赖
- 本地模块声明一组外部模块（依赖）
- 模块系统会检查这些依赖，进而保证这些外部模块能够被加载并在本地模块运行时初始化所有依赖
- 每个模块都会与某个唯一的标识符关联，该标识符通常是JS文件的路径，也可以是模块本身内部声明的命名空间路径字符串中

## 模块加载
- 在浏览器中，加载模块涉及其中的代码，但必须是在所有依赖都加载并执行之后，如果浏览器没有收到依赖模块的代码，则必须发送请求并等待网络返回，收到模块代码之后也需要确定该模块是否也有依赖，然后递归加载所有依赖，直到所有依赖的模块都加载完成，才执行入口模块

## 入口
- 相互依赖的模块必须指定一个入口，也是代码执行的起点，JS会将所有模块构成依赖图

## 静态分析
- 模块中包含发送到浏览器的JS代码经常会被静态分析，分析工具会检查代码结构并在不实际执行代码的情况下推断其行为

## 动态依赖
- 允许开发则在程序结构中动态添加依赖，依赖必须在执行前加载完毕，会增加静态分析的难度
```js
if(loadCondition) {
    require("./moduleA");
}
```
- 模块内部的代码在moduleA加载前都不能执行

## CommonJS
- 使用require指定依赖，使用exports对象定义自己公共的API
- 同步加载，可能会阻塞其他页面操作，适用于服务器
  - 这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于"假死"状态
- 调用require意味着模块会原封不动的加载进来，同时无论require多少次，其模块只会加载一次，模块永远是单例
  - 模块第一次加载后就会被缓存
- 导出的是对模块的浅拷贝值，其他模块修改都可以看见

## AMD
- 异步模块定义系统则以浏览器为目标执行环境，异步加载，不会阻塞
- 让模块声明自己的依赖，而运行在浏览器中的模块系统会按需获取依赖，并在依赖加载完成后立即执行依赖它们的模块
```js
require(["math"],function(math) {
    math.add(2,3);
})
```
- 第一个参数是需要加载的模块，第二个参数是加载完成之后的回调
- 其实现的核心是用函数包装模块的定义
```js
define("a",["b"],function(b) {
    return {
        B: b.print
    }
})
```
- 模块A依赖模块B，与CommonJS不同，支持可选为模块指定字符串标识符
- 允许使用require、exports和动态加载
```js
define("a",["require","exports"],function(require,exports) {
    var b = require("b");
    exports.B = b.print
})
```

## 通用模块定义
```js
(function(root,factory) {
    if(typedef define === 'function' && define.amd) {
        define(["moduleB"],factory);
    } else if(typeof module === "object" && module.exports) {
        module.exports = factory(require("moduleB"));
    } else {
        root.returnExports = factory(root.moduleB);
    }
})(this,function(moduleB) {
    return {};
});
```

## ES6 Module
- script的type=module，遇见该标签会立即下载模块文件，但执行会延迟到文档解析完成
- 借用了AMD和CommonJS许多特性
  - 代码模块在加载后执行
  - 模块只能加载一次，模块是单例
- 新特性
  - 默认在严格模式下，顶级this是undefined，模块中var声明不会添加到window
  - 异步加载（import() 方法）和执行
  - 导出语句必须在顶级模块，不能嵌套在某个块中（不支持动态加载），导出的是一个引用值，内部修改外部可见
  - import会被提升到模块顶部，且导入的值是引用值且只读的，就像是使用了Object.freeze一样