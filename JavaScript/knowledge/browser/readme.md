# 浏览器环境

## 加载脚本
- 除了script引入脚本，还可以通过url(javascript:)协议，即在url的位置写入代码，如果写入的是字符，浏览器会创建新文档展示该字符且丢失原文档内容

## script
- 浏览器一边下载html网页一边开始解析，解析过程中发现script元素就暂停解析，将网页控制权给js引擎，如果该脚本引入外部脚本就需要先下载（也会阻塞html解析）后解析，当js引擎执行完毕将控制权交还给渲染引擎，继续解析html
  - 多个script元素会并行下载，但是会按照书写顺序执行，并行下载有一定数量限制，为了避免过度竞争、防止网络阻塞、减轻服务器压力
  - script没有同源限制，有时候需要其加载第三方脚本，但是可以通过CSP限定加载脚本的来源；也可以给script脚本指定integryty指定脚本的hash内容防止篡改
  - script到defer属性可以延迟脚本执行到dom加载生成后，下载的时候不会阻塞html解析
  - async属性则是下载时不会阻塞渲染，但是无法保证script的执行顺序
  - 动态生成的script然后插入页面，好处是不会阻塞页面渲染，但是无法保证执行顺序（可以设置async=false去避免该问题且不会阻塞html渲染）
- script元素放底部的好处是不会阻塞页面渲染html，且可以在dom结构生成之后调用dom节点不会导致报错（也可以使用DOMContentLoaded事件的回调函数）

## 浏览器组成
- 渲染引擎和js引擎
  - 渲染引擎负责解析html代码为dom，css代码为cssom，合成渲染树，布局和绘制，以上并非严格按顺序执行
  - 现代js引擎处理代码采用“即时编译”，即字节码（先读取代码进行词法分析->进行语法分析->将代码转换为字节码->字节码转换为机器码，字节码不能是不能直接执行的，运行在一个虚拟机上，虚拟机也称之为js引擎）只在运行时编译，用到哪一行编译哪一行，并将编译结果缓存

## window
- 指当前浏览器窗口，也是页面的顶层对象
- 属性
  - opener表示打开当前窗口的父窗口，如果从地址栏输入打开则为null，拿到opener有同源限制，也可以对a标签添加属性rel="noopener"防止新窗口拿到父窗口
  - frames是window的别名，其成员是页面内所有框架窗口，如果iframe设置了id或name，则可以通过id或name引用，iframe的window通过iframe的contentWindow拿到
  - top指向最顶层窗口,parent指向父窗口
  - devicePixelRatio表示一个css像素由多少个物理像素组成
  - innerHeight/innerWidth返回当前窗口可见部分的高度和宽度
  - scrollX/scrollY返回水平和垂直滚动距离
  - isSecureContext表示是否是https协议
- 方法
  - open()打开新窗口
  - close()关闭当前窗口
  - stop()停止加载图片、视频等或在等待加载的对象
  - scrollTo()将文档滚动到指定位置
  - print()跳出打印框
  - getSelection()返回一个Selection对象，表示用户现在选中的文本
  - getComputedStyle()接受一个元素作为参数，返回其样式表最终信息
  - requestAnimationFrame()将执行函数推迟到下一次重流时执行
    - 将requestAnimationFrame返回值给cancleAnimationFram()来取消回调函数执行
  - requestIdleCallback()将函数推迟到系统资源空闲时执行，或者给定属性超过时间限制执行
    - 将requestIdleCallback返回值给cancelIdleCallback()取消回调函数

## navigator
- 包含浏览器和系统信息的对象
- 属性
  - userAgent表示用户的设备信息以及浏览器的厂商等信息
  - geolocation包含用户地理位置的信息，只有在https协议下可用，否则调用以下方法报错
    - Geolocation.getCurrentPosition()得到用户当前位置
    - Geolocation.watchPosition()监听用户位置变化
    - Geolocation.clearWatch()取消监听
  - cookieEnabled表示浏览器的cookie功能是否打开
- 方法
  - sendBeancon()该方法为了解决页面在卸载时用ajax或fetch请求可能被取消问题
    - 异步请求，请求与当前页面的线程脱钩，是作为浏览器进程的任务
    - 不允许自定义http标头，优先级低，不会占用页面资源

## cookie
- 是服务器保存在浏览器的一段文本信息，一般大小不超过4kb（超过则忽略），只有哪些需要让服务器知道的信息才应该放在cookie里面
- 想要改变原本cookie，需要满足key、domain、path、secure都匹配
- 属性
  - expires指定一个具体的到期时间
  - max-age指定存储的时间秒数
  - domain指定属于那个域，只能设置为当前域名或上级域名，为上级域名不能说顶级域名或公共域名
  - path指定浏览器发送http请求哪些路径需要携带该cookie
  - secure指定只有https下才能发送
  - httpOnly指定无法通过js脚本拿到
  - sameSite
    - strict完全禁止第三方cookie
    - lax禁止第三方cookie除非get（a标签、预加载、get表单）请求
    - none关闭该属性

## XMLHttpRequest
- 用于浏览器和服务器之间的通信
- 属性
  - readyState表示当前状态，0表示实例已经生成，1表示open方法调用，2表示send调用，3表示数据正在接收，4表示全部接收完成
  - responseType表示返回的数据类型
  - response即http的body部分，可能是任意类型，由responseType决定
  - responseText
  - responseXML
  - responseURL表示发送数据的服务器网址
  - status和statusText表示状态码和信息
  - timeout多少毫秒后没有得到结果就自动终止，0则表示没有时间限制
  - withCredentials表示跨域请求是否携带cookie
  - upload可以拿到一个对象，得知文件上传的进展，有着和xhr一样的监听函数
- 方法
  - onreadystatechange监听readystate的变化
  - ontimeout监听函数，超时触发
  - onabort监听终止函数
  - onerror监听错误函数
  - onload监听请求成功函数
  - onloadend监听请求完成函数（无论成功或失败）
  - onprogress监听正在发送和加载的数据函数
  - onloadstart监听http发出请求的函数
  - open()指定http请求参数
  - send()发出请求，给参数就是body
  - abort()终止请求 => readystate=4,status=0
  - setRequestHeader()设置请求头
  - getResponseHeader()拿到响应头

## fetch https://www.ruanyifeng.com/blog/2020/12/fetch-tutorial.html
- fetch(url, options)
- 与xhr有三个差异：
  1. fetch使用promise，而xhr使用回调函数
  2. fetch使用模块化设计，api分散在多个对象上(Response、Request、Header对象)，而xhr的输入输出都在同一个接口中
  3. fetch通过数据流对象，可以分块读取，而xhr不支持数据流，只能等数据全部拿到后一次性吐出来
- 只有网络错误或无法连接才会报错，其余都认为是请求成功（即时服务器返回4xx或5xx状态码）
- 属性
  - response.status和response.statusText是同步属性
  - response.ok表示请求是否成功（即response.statu是200到299之间）
  - response.url请求的url
  - response.type请求类型
  - response.redirected表示是否发生过跳转
  - response.headers对应http回应所有标头
    - get(key)
    - has(key)
    - for...
  - body返回一个ReadableStream对象，可以分块读取内容
- 异步方法，且只能调用一次，多次调用则报错，可以使用response.clone()克隆多次然后调用以下方法
  - response.text()拿到文本
  - response.json()拿到json对象
  - response.blob()拿到二进制对象
  - response.formData()拿到表单对象
  - response.arrayBuffer()拿到二进制arrayBuffer对象
